#!/usr/bin/env python3

# ASCII Art Banner
print("""
██╗    ██╗██████╗ ██████╗ ███████╗ ██████╗██████╗  ██████╗ ███╗   ██╗██╗███████╗██╗███████╗██████╗ 
██║    ██║██╔══██╗██╔══██╗██╔════╝██╔════╝██╔══██╗██╔═══██╗████╗  ██║██║██╔════╝██║██╔════╝██╔══██╗
██║ █╗ ██║██████╔╝██║  ██║█████╗  ██║     ██████╔╝██║   ██║██╔██╗ ██║██║█████╗  ██║█████╗  ██████╔╝
██║███╗██║██╔═══╝ ██║  ██║██╔══╝  ██║     ██╔══██╗██║   ██║██║╚██╗██║██║██╔══╝  ██║██╔══╝  ██╔══██╗
╚███╔███╔╝██║     ██████╔╝███████╗╚██████╗██║  ██║╚██████╔╝██║ ╚████║██║██║     ██║███████╗██║  ██║
 ╚══╝╚══╝ ╚═╝     ╚═════╝ ╚══════╝ ╚═════╝╚═╝  ╚═╝ ╚═════╝ ╚═╝  ╚═══╝╚═╝╚═╝     ╚═╝╚══════╝╚═╝  ╚═╝
                                                                                       v1.0
""")

import shodan
import requests
import csv
import os
import urllib3
import time
from urllib.parse import urlparse
from concurrent.futures import ThreadPoolExecutor
from typing import List, Tuple, Optional, Union
from datetime import datetime
import socket
from dns import resolver, reversename

# Disable SSL warnings since we're dealing with potentially self-signed certificates
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

class WordPressCronScanner:
    """
    A scanner class that identifies WordPress sites with exposed wp-cron.php endpoints
    and cross-references them with HackerOne bug bounty programs.
    """

    def __init__(self, shodan_api_key: str):
        """
        Initialize the scanner with necessary API keys and configurations.
        
        Args:
            shodan_api_key (str): API key for Shodan.io
        """
        self.shodan_api = shodan.Shodan(shodan_api_key)
        self.session = requests.Session()
        # Disable SSL verification for handling self-signed certificates
        self.session.verify = False
        # Set timeout to prevent hanging on slow responses
        self.session.timeout = 10
        # Add user-agent to be more transparent about the scanning
        self.session.headers.update({
            'User-Agent': 'WordPress-Cron-Scanner/1.0 (Security Research)'
        })
        # Counter for progress tracking
        self.current_progress = 0
        self.total_items = 0

    def update_progress(self, message: str, increment: bool = True) -> None:
        """
        Update and display the progress of current operation.
        
        Args:
            message (str): Status message to display
            increment (bool): Whether to increment the progress counter
        """
        if increment:
            self.current_progress += 1
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        progress_str = f"[{timestamp}] [{self.current_progress}/{self.total_items}] {message}"
        print(progress_str)

    def get_domain_from_ip(self, ip: str) -> Optional[str]:
        """
        Attempt to get the domain name from an IP address using reverse DNS lookup.
        
        Args:
            ip (str): IP address to lookup
            
        Returns:
            Optional[str]: Domain name if found, None otherwise
        """
        try:
            # Try standard reverse DNS lookup first
            domain = socket.gethostbyaddr(ip)[0]
            if domain and domain != ip:
                print(f"[+] Found domain {domain} for IP {ip}")
                return domain
        except (socket.herror, socket.gaierror):
            try:
                # Try using dnspython as fallback
                addr = reversename.from_address(ip)
                answers = resolver.resolve(addr, "PTR")
                if answers:
                    domain = str(answers[0])
                    if domain and domain != ip:
                        print(f"[+] Found domain {domain} for IP {ip}")
                        return domain
            except Exception as e:
                print(f"[*] Could not resolve domain for IP {ip}: {str(e)}")
        return None

    def get_site_url(self, result: dict) -> Optional[Tuple[str, Optional[str]]]:
        """
        Extract site URL and domain from Shodan result.
        
        Args:
            result (dict): Shodan result dictionary
            
        Returns:
            Optional[Tuple[str, Optional[str]]]: Tuple of (site_url, domain) if valid, None otherwise
        """
        if 'ip_str' not in result:
            return None
            
        host = result['ip_str']
        port = result.get('port', 80)
        protocol = 'https' if port == 443 else 'http'
        
        # Try to get domain from various Shodan fields
        domain = None
        if 'domains' in result and result['domains']:
            domain = result['domains'][0]
        elif 'hostnames' in result and result['hostnames']:
            domain = result['hostnames'][0]
        else:
            # Try reverse DNS lookup
            domain = self.get_domain_from_ip(host)
            
        # Construct the site URL
        site_url = f"{protocol}://{domain if domain else host}"
        return (site_url, domain)

    def get_wordpress_sites(self) -> List[Tuple[str, Optional[str]]]:
        """
        Search for WordPress sites using Shodan API.
        
        Returns:
            List[Tuple[str, Optional[str]]]: List of tuples containing (site_url, domain)
        """
        wordpress_sites = set()  # Using a set to avoid duplicates
        try:
            print("\n[+] Initiating Shodan search for WordPress sites...")
            
            queries = [
                'http.component:wordpress',
                'http.html:"wp-content"',
                'http.html:"wp-includes"',
                'http.title:"WordPress"',
                'http.favicon.hash:"-1507567067"'
            ]
            
            for query in queries:
                try:
                    print(f"[+] Searching Shodan with query: {query}")
                    results = self.shodan_api.search(query, limit=100)
                    
                    if not results.get('matches'):
                        print(f"[*] No results for query: {query}")
                        continue
                        
                    print(f"[+] Processing {len(results['matches'])} results")
                    for result in results['matches']:
                        site_info = self.get_site_url(result)
                        if site_info and site_info not in wordpress_sites:
                            wordpress_sites.add(site_info)
                            url, domain = site_info
                            status = f"domain {domain}" if domain else "IP only"
                            print(f"[+] Found WordPress site: {url} ({status})")
                    
                    if len(wordpress_sites) >= 100:
                        print(f"\n[+] Reached limit of {len(wordpress_sites)} sites, stopping search")
                        break
                        
                    time.sleep(1)
                    
                except shodan.APIError as e:
                    error_msg = str(e).lower()
                    print(f"[-] Error with query '{query}': {e}")
                    if "daily search usage limit reached" in error_msg:
                        print("[-] Daily search limit reached")
                        return list(wordpress_sites)
                    time.sleep(5)
                    continue
                
            print(f"\n[+] Found {len(wordpress_sites)} unique WordPress sites across all queries")
            
        except shodan.APIError as e:
            print(f"[-] Error searching Shodan: {e}")
            
        return list(wordpress_sites)

    def check_wp_cron(self, url):
        try:
            wp_cron_url = f"{url}/wp-cron.php"
            response = requests.get(wp_cron_url, timeout=10, verify=False)
            print(f"[*] Checking {wp_cron_url} - Status: {response.status_code}")
            return response.status_code == 200
        except requests.exceptions.SSLError:
            print(f"[!] SSL Error for {url}")
            return False
        except requests.exceptions.RequestException as e:
            print(f"[!] Error checking {url}: {str(e)}")
            return False

    def get_hackerone_programs(self) -> List[dict]:
        """
        Fetch public HackerOne programs using their API.
        
        Returns:
            List[dict]: List of HackerOne program data
        """
        programs = []
        try:
            print("\n[+] Fetching HackerOne public programs...")
            url = "https://api.hackerone.com/v1/hackers/programs"
            response = self.session.get(url)
            if response.status_code == 200:
                programs = response.json().get('data', [])
                print(f"[+] Successfully retrieved {len(programs)} HackerOne programs")
            else:
                print(f"[-] Failed to fetch HackerOne programs: HTTP {response.status_code}")
        except requests.RequestException as e:
            print(f"[-] Error fetching HackerOne programs: {e}")
        return programs

    def check_scope(self, site_url: str, programs: List[dict]) -> List[Tuple[str, str]]:
        """
        Check if a site is in scope of any HackerOne program.
        
        Args:
            site_url (str): URL of the WordPress site
            programs (List[dict]): List of HackerOne programs
            
        Returns:
            List[Tuple[str, str]]: List of matches (site_url, program_url)
        """
        matches = []
        domain = urlparse(site_url).netloc
        
        print(f"\n[*] Checking scope for domain: {domain}")
        
        for program in programs:
            try:
                attributes = program.get('attributes', {})
                handle = attributes.get('handle')
                
                if not handle:
                    continue
                
                # Try different possible locations for scope information
                scope = (
                    attributes.get('scope', {}).get('in_scope', []) or  # New API format
                    program.get('relationships', {}).get('structured_scopes', {}).get('data', []) or  # Alternative format
                    []
                )
                
                for target in scope:
                    asset_identifier = (
                        target.get('asset_identifier', '') or  # New API format
                        target.get('attributes', {}).get('asset_identifier', '') or  # Alternative format
                        target.get('attributes', {}).get('value', '')  # Another possible format
                    )
                    
                    # More flexible domain matching
                    if asset_identifier:
                        # Remove wildcards and clean up the asset identifier
                        clean_asset = asset_identifier.replace('*.', '').strip()
                        if clean_asset in domain or domain in clean_asset:
                            program_url = f"https://hackerone.com/{handle}"
                            matches.append((site_url, program_url))
                            print(f"[+] Found match: {site_url} -> {program_url}")
                            print(f"    Asset identifier: {asset_identifier}")
                            break
                
            except Exception as e:
                print(f"[-] Error processing program {program.get('attributes', {}).get('handle', 'unknown')}: {str(e)}")
                continue
                
        return matches

    def scan_and_save(self):
        print("\n[+] Starting scan at", datetime.now().strftime("%Y-%m-%d %H:%M:%S"))
        print("\n[+] Initiating Shodan search for WordPress sites...")
        
        wordpress_sites = self.get_wordpress_sites()
        total_sites = len(wordpress_sites)
        print(f"\n[+] Found {total_sites} WordPress sites to check")
        
        results = []
        for i, (site_url, domain) in enumerate(wordpress_sites, 1):
            print(f"[*] [{i}/{total_sites}] Checking {site_url}")
            is_vulnerable = self.check_wp_cron(site_url)
            if is_vulnerable:
                print(f"[!] Vulnerable: {site_url}")
                results.append({
                    'url': site_url,
                    'domain': domain,
                    'vulnerable': True,
                    'checked_at': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                })
            else:
                print(f"[-] Not vulnerable: {site_url}")
                results.append({
                    'url': site_url,
                    'domain': domain,
                    'vulnerable': False,
                    'checked_at': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                })

        # Save results to CSV
        if results:
            with open('results.csv', 'w', newline='') as f:
                writer = csv.DictWriter(f, fieldnames=['url', 'domain', 'vulnerable', 'checked_at'])
                writer.writeheader()
                writer.writerows(results)
                print(f"\n[+] Results saved to results.csv")
                print(f"[+] Total sites checked: {total_sites}")
                print(f"[+] Vulnerable sites found: {sum(1 for r in results if r['vulnerable'])}")
        else:
            print("\n[-] No results to save")

def main():
    """
    Main entry point of the script.
    Handles initialization and execution of the scanner.
    """
    # Check for required API key
    shodan_api_key = os.getenv('SHODAN_API_KEY')
    if not shodan_api_key:
        print("[-] Error: Please set the SHODAN_API_KEY environment variable")
        print("    Export it using: export SHODAN_API_KEY='your-api-key-here'")
        return

    # Initialize and run scanner
    try:
        scanner = WordPressCronScanner(shodan_api_key)
        scanner.scan_and_save()
    except KeyboardInterrupt:
        print("\n[-] Scan interrupted by user")
    except Exception as e:
        print(f"\n[-] An unexpected error occurred: {str(e)}")

if __name__ == "__main__":
    main() 